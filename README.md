# Лабораторная работа №1

_Матричные операции с элементами кольца_

---

## Постановка задачи

Разработать программу для выполнения операций над кольцевыми матрицами, хранящими элементы различных типов (`int`, `float`).  
Система должна поддерживать:
- ввод и вывод матриц
- выполнение арифметических операций (сложение, вычитание, умножение)
- работу с элементами произвольного пользовательского типа
- отображение информации о кольцевых матрицах

---

## Описание решения

---

### Int.h / Int.c

#### Структура `Int`
```c
typedef struct Int {
    RingInfo *ringInfo;
    int integer;
} Int;
```

##### Поля:
- `ringInfo` — указатель на структуру `RingInfo`, описывающую операции кольца
- `integer` — целое значение, хранящееся в объекте

#### Функции:

- `void* sumInt(void* x, void* y)`  
    > Складывает два значения типа `Int`  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **x**, **y** — указатели на `Int`  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новый объект `Int`, содержащий сумму

- `void* minusInt(void* x)`  
    > Возвращает противоположное значение для `Int`  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **x** — указатель на `Int`  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новый `Int` с противоположным значением

- `void* multiInt(void* x, void* y)`  
    > Умножает два объекта типа `Int`  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **x**, **y** — указатели на `Int`  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Результат умножения (`Int*`)

- `void printInt(void* integer)`  
    > Выводит значение `Int` на экран  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **integer** — указатель на `Int`

- `void* zeroInt()`  
    > Возвращает нулевой элемент кольца (`0`)  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новый `Int`, содержащий 0

- `void* oneInt()`  
    > Возвращает единичный элемент кольца (`1`)  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новый `Int`, содержащий 1

- `void* getInt(int value)`  
    > Создаёт `Int` с заданным значением  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **value** — целое значение  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новый `Int`

- `void* collectInt(int value)`  
    > Выделяет память и инициализирует `Int` со всеми операциями кольца  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **value** — целое значение  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Указатель на `Int`

---

### Float.h / Float.c

#### Структура `Float`
```c
typedef struct Float {
    RingInfo *ringInfo;
    float real;
} Float;
```

##### Поля:
- `ringInfo` — указатель на структуру `RingInfo`, содержащую операции кольца
- `real` — число с плавающей точкой (`float`), хранимое в объекте

#### Функции:

- `void* sumFloat(void* x, void* y)`  
    > Складывает два значения типа `Float`  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **x**, **y** — указатели на `Float`  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новый объект `Float`, содержащий сумму

- `void* minusFloat(void* x)`  
    > Возвращает противоположное значение для `Float`  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **x** — указатель на `Float`  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новый `Float` с противоположным значением

- `void* multiFloat(void* x, void* y)`  
    > Умножает два объекта типа `Float`  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **x**, **y** — указатели на `Float`  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Результат умножения (`Float*`)

- `void printFloat(void* value)`  
    > Выводит значение `Float` на экран с точностью до 3 знаков после запятой  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **value** — указатель на `Float`

- `void* randomFloat()`  
    > Генерирует случайное значение `Float` в диапазоне приблизительно от 1 до 100  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новый `Float` со случайным значением

- `void* zeroFloat()`  
    > Возвращает нулевой элемент кольца (`0.0`)  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новый `Float`, содержащий 0.0

- `void* oneFloat()`  
    > Возвращает единичный элемент кольца (`1.0`)  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новый `Float`, содержащий 1.0

- `void* getFloat(float value)`  
    > Создаёт `Float` с заданным значением  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **value** — значение `float`  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новый `Float`

- `void* collectFloat(float value)`  
    > Выделяет память и инициализирует `Float` с нужными операциями кольца  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **value** — значение `float`  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Указатель на `Float`

---

### Matrix.h / Matrix.c

#### Структура `Element`
```c
typedef struct Element {
    RingInfo *ringInfo;
    void *value;
} Element;
```

##### Поля:
- `ringInfo` — указатель на кольцо, описывающее операции над значением
- `value` — указатель на значение (`Int*`, `Float*` и др.)

---

#### Структура `Matrix`
```c
typedef struct Matrix {
    Element **data;
    int size;
} Matrix;
```

##### Поля:
- `data` — одномерный массив указателей на `Element` (размером `size × size`)
- `size` — размер квадратной матрицы

---

#### Создание

- `Matrix* randomMatrix(RingInfo* ringInfo, int size)`  
    > Создаёт квадратную матрицу заданного размера со случайными значениями  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **ringInfo** — описание операций кольца  
    >   * **size** — размер матрицы  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Указатель на новую `Matrix`

- `Matrix* E(RingInfo* ringInfo, int size)`  
    > Создаёт единичную матрицу  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Матрица, в которой диагональ содержит `one`, остальные — `zero`

- `Element* collectElement(RingInfo* ringInfo, void* value)`  
    > Оборачивает значение в `Element`  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **ringInfo** — ссылка на кольцо  
    >   * **value** — значение (`Int*`, `Float*`)  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новый элемент

---

#### Декомпозиция

- `Element** getLine(int lineNumber, Matrix* matrix)`  
    > Возвращает строку матрицы по номеру (нумерация с 1)  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **lineNumber** — номер строки  
    >   * **matrix** — указатель на матрицу  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Массив указателей на `Element`

- `Element** getColumn(int columnNumber, Matrix* matrix)`  
    > Возвращает столбец матрицы по номеру (нумерация с 1)

---

#### Операции

- `Matrix* sumMatrix(Matrix* matrix1, Matrix* matrix2)`  
    > Складывает две матрицы поэлементно  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Результат записывается в `matrix1`

- `Matrix* multiMatrix(Matrix* matrix1, Matrix* matrix2)`  
    > Умножает две матрицы по правилам линейной алгебры  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Результат сохраняется в `matrix1`

- `Matrix* multiScalar(Matrix* matrix, void* multiplier)`  
    > Умножает все элементы матрицы на заданное значение  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **multiplier** — значение (`Int*`, `Float*`)  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Результат сохраняется в `matrix`

- `Matrix* sumLine(Matrix* matrix, int line1, int line2, void* multiplier)`  
    > Складывает строку `line2`, умноженную на `multiplier`, к строке `line1`

---

#### Вывод

- `void printMatrix(Matrix* matrix)`  
    > Выводит всю матрицу в табличной форме

- `void printLine(Element** line, int size)`  
    > Выводит одну строку матрицы

- `void printColumn(Element** column, int size)`  
    > Выводит один столбец матрицы

---

### RingInfo.h / RingInfo.c

#### Структура `RingInfo`
```c
typedef struct RingInfo {
    void *(*sum)(void *, void *);
    void *(*zero)();
    void *(*minus)(void *);
    void *(*multi)(void *, void *);
    void (*printValue)(void *);
    void *(*randomValue)();
    void *(*getType)();
    void *(*one)();
} RingInfo;
```

##### Поля:
- `sum` — функция сложения двух элементов
- `zero` — функция, возвращающая нулевой элемент
- `minus` — функция, возвращающая противоположный элемент
- `multi` — функция умножения двух элементов
- `printValue` — функция вывода элемента
- `randomValue` — функция генерации случайного значения
- `getType` — функция получения значения из пользовательского типа
- `one` — функция, возвращающая единичный элемент

#### Функции:

- `RingInfo* Create(...)`  
    > Создаёт структуру `RingInfo` с набором указателей на функции операций кольца  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **sum** — операция сложения  
    >   * **zero** — функция, возвращающая 0  
    >   * **minus** — операция унарного минуса  
    >   * **multi** — операция умножения  
    >   * **printValue** — функция вывода  
    >   * **randomValue** — генератор случайного значения  
    >   * **getType** — функция создания значения из базового типа  
    >   * **one** — функция, возвращающая 1  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Указатель на инициализированную структуру `RingInfo`


---

### Menu.h

#### Функции пользовательского интерфейса

- `void selectType()`  
    > Отображает меню выбора типа значений  
    >
    > Предлагает пользователю выбрать:
    > 
    > 1 — целые числа  
    >   
    > 2 — числа с плавающей точкой

- `void selectAction()`  
    > Отображает список доступных операций над матрицами:
    >
    > 1. Случайная единичная матрица  
    > 2. Получить строку  
    > 3. Получить столбец  
    > 4. Сложение матриц  
    > 5. Умножение матриц  
    > 6. Умножение на скаляр  
    > 7. Прибавить к строке линейную комбинацию другой строки

---

# Лабораторная работа №2  
_Обобщённая работа с последовательностями на шаблонах_

---

## Постановка задачи  

Реализовать иерархию классов для работы с последовательностями с использованием шаблонов.  
Поддержать основные операции (вставка, удаление, доступ по индексу, фильтрация, отображение, свёртка).  
Обеспечить интерфейс пользователя для работы с различными типами данных (например, `int`, `float`).

---

## Описание решения  
### Используемые типы данных  
- `Sequence<Type>` — абстрактный класс для последовательностей  
- `ArraySequence<Type>` — реализация последовательности на динамическом массиве  
- `ListSequence<Type>` — реализация последовательности на двусвязном списке  
- `Mapper<Type>` — функция, применяемая к каждому элементу (аналог map)  
- `Condition<Type>` — функция-фильтр (аналог filter)  
- `Reducer<Type>` — функция для свёртки значений (аналог reduce)  

---

## Функции

### Sequence.hpp

#### Шаблонный абстрактный класс `Sequence<Type>`


#### Методы:

- `~Sequence()`  
    > Виртуальный деструктор

- `Create() const -> Sequence<Type>*`  
    > Создаёт пустую последовательность того же типа  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новый объект `Sequence<Type>`

- `Get(index: int) const -> Type&`  
    > Возвращает элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — индекс элемента  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `Size() const noexcept -> int`  
    > Возвращает количество элементов  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Размер последовательности

- `Append(item: const Type&) noexcept`  
    > Добавляет элемент в конец  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — добавляемый элемент

- `Prepend(item: const Type&) noexcept`  
    > Добавляет элемент в начало  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — добавляемый элемент

- `Insert(item: const Type&, index: int)`  
    > Вставляет элемент в заданную позицию  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — элемент  
    >   * **index** — позиция

- `Remove(index: int)`  
    > Удаляет элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — индекс элемента

- `IsEmpty() const -> bool`  
    > Проверяет, пуста ли последовательность  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * `true`, если элементов нет

- `GetFirst() const -> Type&`  
    > Возвращает первый элемент  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `GetLast() const -> Type&`  
    > Возвращает последний элемент  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `Map(func: Mapper<Type>) const -> Sequence<Type>*`  
    > Возвращает новую последовательность, где к каждому элементу применена функция  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **func** — функция отображения
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новая последовательность

- `Where(filter: Condition<Type>) const -> Sequence<Type>*`  
    > Возвращает новую последовательность из элементов, удовлетворяющих фильтру  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **filter** — функция-фильтр
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новая последовательность

- `Reduce(reduce: Reducer<Type>, base: Type) const -> Type`  
    > Последовательно сворачивает элементы с помощью аккумулятора  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **reduce** — функция аккумуляции  
    >   * **base** — начальное значение  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Результат аккумуляции

- `operator<<(ostream& os, Sequence<Type>* array)`  
    > Вывод последовательности в виде строки  
    >
    > _ФОРМАТ:_  
    >   * `[elem1, elem2, ...]`

- `operator==(sequence: const Sequence<Type>&) -> bool`  
    > Сравнивает две последовательности поэлементно

- `operator[](index: int) const -> Type&`  
    > Доступ к элементу по индексу


---

### DynamicArray.hpp

#### Шаблонный класс `DynamicArray<Type>`

> Реализация динамического массива с возможностью изменения размера, индексированием и перегрузкой операторов

```cpp
template<typename Type>
class DynamicArray {
private:
    Type* data;
    size_t size;
public:
    ...
};
```

---

##### Поля:

- `data` — указатель на блок памяти, содержащий элементы массива
- `size` — текущее количество элементов в массиве

---

#### Конструкторы и деструктор:

- `DynamicArray()`  
    > Конструктор по умолчанию  
    >
    > Создаёт массив из одного элемента, инициализированного значением по умолчанию

- `DynamicArray(size: size_t)`  
    > Конструктор пустого массива заданного размера  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **size** — количество элементов

- `DynamicArray(items: Type*, size: size_t)`  
    > Конструктор из массива  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **items** — массив элементов  
    >   * **size** — количество

- `DynamicArray(dynamicArray: const DynamicArray<Type>&)`  
    > Конструктор копирования

- `DynamicArray(head: Type, args...)`  
    > Шаблонный конструктор с произвольным количеством аргументов  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **head, args...** — значения, из которых строится массив

- `~DynamicArray()`  
    > Деструктор. Освобождает память

---

#### Методы:

- `void Resize(newSize: size_t)`  
    > Изменяет размер массива  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **newSize** — новый размер массива

- `Type& Get(index: int) const`  
    > Возвращает элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — позиция  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент  
    >
    > _ИСКЛЮЧЕНИЯ:_  
    >   * `std::out_of_range`, если индекс некорректен

- `void Set(index: int, element: Type)`  
    > Заменяет элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — позиция  
    >   * **element** — новое значение

- `int Size() const noexcept`  
    > Возвращает текущий размер массива  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Количество элементов

---

#### Операторы:

- `operator==(sequence: const DynamicArray<Type>&) -> bool`  
    > Сравнивает два массива поэлементно

- `operator[](index: int) const -> Type&`  
    > Индексация массива  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `operator<<(os: ostream&, array: const DynamicArray<Type>&)`  
    > Форматированный вывод массива в виде `[x1, x2, ..., xn]`


---

### ArraySequence.hpp

#### Шаблонный класс `ArraySequence<Type>`

> Конкретная реализация абстрактного класса `Sequence<Type>`, основанная на `DynamicArray<Type>`

```cpp
template<typename Type>
class ArraySequence : public Sequence<Type> {
private:
    DynamicArray<Type>* items;
public:
    ...
};
```

---

##### Поля:

- `items` — указатель на внутренний динамический массив, в котором хранятся элементы последовательности (`DynamicArray<Type>*`)

---

#### Методы:

- `ArraySequence()`  
    > Конструктор по умолчанию  
    >
    > Создаёт пустую последовательность

- `ArraySequence(items: Type*, size: size_t)`  
    > Конструктор из массива  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **items** — массив значений  
    >   * **size** — количество элементов

- `ArraySequence(dynamicArray: const DynamicArray<Type>&)`  
    > Конструктор копирования из `DynamicArray`  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **dynamicArray** — массив-источник

- `~ArraySequence()`  
    > Деструктор. Освобождает память

- `Create() const -> Sequence<Type>*`  
    > Возвращает новый пустой объект `ArraySequence<Type>`

- `Get(index: int) const -> Type&`  
    > Возвращает элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — индекс  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `Size() const noexcept -> int`  
    > Возвращает количество элементов  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Размер последовательности

- `Append(item: const Type&) noexcept`  
    > Добавляет элемент в конец  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — добавляемый элемент

- `Prepend(item: const Type&) noexcept`  
    > Добавляет элемент в начало  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — добавляемый элемент

- `Insert(item: const Type&, index: int)`  
    > Вставляет элемент на позицию  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — вставляемый элемент  
    >   * **index** — позиция вставки

- `Remove(index: int)`  
    > Удаляет элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — позиция элемента

- `Set(index: int, value: Type)`  
    > Устанавливает значение по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — индекс элемента  
    >   * **value** — новое значение

---

### List.hpp

#### Шаблонный класс `LinkedList<Type>`

> Односвязный список с итераторами и базовыми операциями над элементами

---

#### Вспомогательная структура `Node<Type>`
```cpp
template<typename Type>
class Node {
public:
    Type value;
    Node<Type>* next;

    ...
};
```

##### Поля:
- `value` — значение узла
- `next` — указатель на следующий элемент

---

#### Класс `LinkedList<Type>`

```cpp
template<typename Type>
class LinkedList {
private:
    Node<Type>* head;
    Node<Type>* tail;
    size_t size;
public:
    ...
};
```

---

##### Поля:
- `head` — указатель на первый элемент списка (`Node<Type>*`)
- `tail` — указатель на последний элемент списка (`Node<Type>*`)
- `size` — количество элементов в списке (`size_t`)

---

#### Методы:

- `LinkedList()`  
    > Конструктор по умолчанию. Создаёт пустой список

- `LinkedList(items: Type*, size: size_t)`  
    > Создаёт список из массива  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **items** — массив значений  
    >   * **size** — количество элементов

- `LinkedList(list: const LinkedList<Type>&)`  
    > Конструктор копирования

- `LinkedList(head: Type, args...)`  
    > Шаблонный конструктор с аргументами  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **head** — первый элемент  
    >   * **args...** — оставшиеся элементы

- `~LinkedList()`  
    > Деструктор. Удаляет все узлы списка

- `IsEmpty() const -> bool`  
    > Проверяет, пуст ли список  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * `true`, если нет элементов

- `Size() const -> size_t`  
    > Возвращает количество элементов

- `Get(index: int) const -> Type&`  
    > Возвращает элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — позиция  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `GetFirst() const -> Type&`  
    > Первый элемент  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на `head->value`

- `GetLast() const -> Type&`  
    > Последний элемент  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на `tail->value`

- `Append(value: const Type&)`  
    > Добавляет элемент в конец

- `Prepend(value: const Type&)`  
    > Добавляет элемент в начало

- `Insert(index: int, value: const Type&)`  
    > Вставляет элемент по индексу

- `Remove(index: int)`  
    > Удаляет элемент по индексу

- `operator==(list: const LinkedList<Type>&) -> bool`  
    > Сравнение списков поэлементно

- `operator[](index: int) const -> Type&`  
    > Обращение к элементу через `[]`

- `operator<<(os: ostream&, list: const LinkedList&)`  
    > Печатает список в формате: `[x1, x2, ..., xn]`

- `Begin() -> ListIterator`  
    > Итератор на первый элемент

- `End() -> ListIterator`  
    > Итератор на `nullptr`

---

#### Вложенный класс `ListIterator`

```cpp
class ListIterator {
private:
    Node<Type>* current;
public:
    ...
};
```

##### Поля:
- `current` — указатель на текущий узел в процессе итерации

---

##### Методы:


- `operator++()`  
    > Переход к следующему элементу

- `operator*() -> Type&`  
    > Доступ к значению

- `operator==(...)`, `operator!=(...)`  
    > Сравнение итераторов


---

### ListSequence.hpp

#### Шаблонный класс `ListSequence<Type>`

> Конкретная реализация абстрактного класса `Sequence<Type>`, основанная на связном списке `LinkedList<Type>`

```cpp
template<typename Type>
class ListSequence : public Sequence<Type> {
private:
    LinkedList<Type>* items;
public:
    ...
};
```

---

#### Методы:

- `ListSequence()`  
    > Конструктор по умолчанию  
    >
    > Создаёт пустую последовательность на базе пустого списка

- `ListSequence(items: Type*, size: size_t)`  
    > Создаёт список из массива элементов  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **items** — массив  
    >   * **size** — количество элементов

- `ListSequence(listSequence: const ListSequence<Type>&)`  
    > Конструктор копирования  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **listSequence** — другая последовательность

- `ListSequence(head: Type, args...)`  
    > Инициализация через список аргументов  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **head, args...** — значения, добавляемые в последовательность

- `~ListSequence()`  
    > Деструктор. Освобождает память

- `Create() const -> Sequence<Type>*`  
    > Возвращает новый пустой объект `ListSequence<Type>`

- `Get(index: int) const -> Type&`  
    > Получает элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — индекс  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `Size() const noexcept -> int`  
    > Возвращает количество элементов  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Размер последовательности

- `Append(item: const Type&) noexcept`  
    > Добавляет элемент в конец

- `Prepend(item: const Type&) noexcept`  
    > Добавляет элемент в начало

- `Insert(item: const Type&, index: int)`  
    > Вставляет элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — добавляемый элемент  
    >   * **index** — позиция вставки

- `Remove(index: int)`  
    > Удаляет элемент по индексу

- `Begin() -> Iterator`  
    > Возвращает итератор на начало списка

- `End() -> Iterator`  
    > Возвращает итератор на конец списка

---

### Menu.hpp

#### Назначение

Модуль `Menu.hpp` реализует пользовательское текстовое меню для управления объектами типа `Sequence<float>`, позволяя пользователю выполнять базовые операции с последовательностями (добавление, вставка, вывод и т.д.).

---

#### Макросы

- `EMPTY`  
    > Проверка, существует ли объект `seq`.  
    > Если `nullptr` — выводит сообщение `"Sequence is empty"` и завершает текущую операцию.

- `DELETE`  
    > Удаляет объект `seq` и устанавливает его в `nullptr`.

- `PRINT`  
    > Печатает текущую последовательность `seq` на экран.

---

#### Функции

- `void talker()`  
    > Выводит список доступных действий пользователю:
    >
    > 1. Создать `ArraySequence`  
    > 2. Создать `ListSequence`  
    > 3. Печать  
    > 4. Первый элемент  
    > 5. Последний элемент  
    > 6. Получить по индексу  
    > 7. Размер  
    > 8. Добавить в конец  
    > 9. Добавить в начало  
    > 10. Вставить по индексу  
    > 0. Завершить программу

- `void menu()`  
    > Основной цикл пользовательского взаимодействия.  
    > Поддерживает все действия, описанные в `talker()`:
    >
    > _Локальные переменные:_  
    >   * `flag` — флаг завершения  
    >   * `choice` — пользовательский выбор  
    >   * `index` — индекс для операций  
    >   * `value` — значение типа `float`  
    >   * `seq` — текущая последовательность (`Sequence<float>*`)

    > _Основные действия:_  
    >   * Создание новых последовательностей (`ArraySequence`, `ListSequence`)  
    >   * Вывод содержимого  
    >   * Получение элементов (первый, последний, по индексу)  
    >   * Изменение последовательности (добавление, вставка)  
    >   * Очистка и завершение работы
---

# Лабораторная работа №3  
_Очереди и приоритетные очереди на обобщённых структурах_

---

## Постановка задачи  

Реализовать обобщённую очередь (`Queue<Type>`) с поддержкой операций добавления, удаления и отображения.  
Дополнительно реализовать приоритетную очередь (`PriorityQueue<Key, Priority>`), основанную на очереди пар ключ-приоритет.  
Поддержать работу с различными типами данных (`int`, `float`, `Complex`, и т. д.) через шаблоны.  
Обеспечить возможность применения функций `Map`, `Where`, `Reduce` к элементам очереди.  
Создать интерфейс взаимодействия с пользователем.

---

## Описание решения  
### Используемые типы данных  
- `Queue<Type>` — шаблонная очередь, реализованная через `Sequence<Type>`  
- `PriorityQueue<Key, Priority>` — шаблонная приоритетная очередь на базе `Queue<Pair<Key, Priority>>`  
- `Pair<Type1, Type2>` — пара значений с шаблонными типами  
- `Complex` — структура для комплексных чисел  
- `Mapper<T>`, `Condition<T>`, `Reducer<T>` — функции отображения, фильтрации и свёртки  

---

## Функции

### Complex.hpp

#### Класс `Complex`

> Класс для работы с комплексными числами, поддерживает арифметику с числами типа `double` и перегрузку операторов

```cpp
class Complex {
private:
    double realPart;
    double imgPart;
public:
    ...
};
```

---

##### Поля:

- `realPart` — вещественная часть комплексного числа
- `imgPart` — мнимая часть комплексного числа

---

#### Конструкторы и деструктор:

- `Complex()`  
    > Конструктор по умолчанию  
    >
    > Инициализирует комплексное число `(0 + 0i)`

- `Complex(rp: double, ip: double)`  
    > Конструктор с явным указанием действительной и мнимой части  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **rp** — вещественная часть  
    >   * **ip** — мнимая часть

- `explicit Complex(rp: double)`  
    > Конструктор для действительного числа (мнимая часть = 0)

- `~Complex()`  
    > Деструктор по умолчанию

---

#### Методы:

- `GetRealPart() const noexcept -> double`  
    > Возвращает вещественную часть

- `GetImgPart() const noexcept -> double`  
    > Возвращает мнимую часть

- `operator=(other: const Complex&) -> Complex&`  
    > Оператор присваивания  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **other** — объект `Complex`  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на текущий объект

- `operator==(other: const Complex&) const -> bool`  
    > Проверка равенства двух комплексных чисел

---

#### Перегруженные операторы

##### Сложение

- `operator+(left: const Complex&, right: const Complex&) -> Complex`  
- `operator+(left: const double&, right: const Complex&) -> Complex`  
- `operator+(left: const Complex&, right: const double&) -> Complex`

##### Вычитание

- `operator-(left: const Complex&, right: const Complex&) -> Complex`  
- `operator-(left: const double&, right: const Complex&) -> Complex`  
- `operator-(left: const Complex&, right: const double&) -> Complex`

##### Умножение

- `operator*(left: const Complex&, right: const Complex&) -> Complex`  
- `operator*(left: const double&, right: const Complex&) -> Complex`  
- `operator*(left: const Complex&, right: const double&) -> Complex`

##### Вывод

- `operator<<(os: ostream&, complex: Complex*) -> ostream&`  
    > Выводит число в следующем виде:  
    >
    > - `0`, если обе части равны 0  
    > - `a`, если только действительная часть  
    > - `a+bi` или `a-bi` — общее представление

---

### Sequence.hpp

#### Шаблонный абстрактный класс `Sequence<Type>`

> Абстракция для работы с последовательностями. Поддерживает доступ, вставку, удаление, фильтрацию и отображение значений.


#### Методы:

- `~Sequence()`  
    > Виртуальный деструктор

- `Create() const -> Sequence<Type>*`  
    > Создаёт пустую последовательность того же типа  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новый объект-последовательность

- `Get(index: int) const -> Type&`  
    > Возвращает элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — позиция  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `Size() const noexcept -> int`  
    > Возвращает количество элементов  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Размер последовательности

- `Append(item: const Type&) noexcept`  
    > Добавляет элемент в конец

- `Prepend(item: const Type&) noexcept`  
    > Добавляет элемент в начало

- `Insert(item: const Type&, index: int)`  
    > Вставляет элемент на заданную позицию  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — вставляемое значение  
    >   * **index** — позиция вставки

- `Remove(index: int)`  
    > Удаляет элемент по индексу

- `IsEmpty() -> bool`  
    > Проверяет, пуста ли последовательность  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * `true`, если пустая

- `GetFirst() const -> Type&`  
    > Возвращает первый элемент  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `GetLast() const -> Type&`  
    > Возвращает последний элемент  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `Map(func: Mapper<Type>) const -> Sequence<Type>*`  
    > Применяет функцию к каждому элементу и возвращает новую последовательность  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **func** — функция преобразования  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новая последовательность

- `Where(filter: Condition<Type>) const -> Sequence<Type>*`  
    > Оставляет только элементы, удовлетворяющие условию  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **filter** — логическая функция  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Отфильтрованная последовательность

- `Reduce(reduce: Reducer<Type>, base: Type) const -> Type`  
    > Применяет аккумулятор к каждому элементу, начиная с базового  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Результат свёртки

---

#### Операторы:

- `operator==(sequence: const Sequence<Type>&) -> bool`  
    > Сравнивает последовательности поэлементно

- `operator[](index: int) const -> Type&`  
    > Доступ по индексу

- `operator<<(os: ostream&, array: Sequence<Type>*) -> ostream&`  
    > Форматированный вывод: `[a, b, c]`

---

### List.hpp

#### Шаблонная структура `Node<Type>`

```cpp
template<typename Type>
class Node {
public:
    Type value;
    Node<Type>* next;

    explicit Node(Type value);
};
```

##### Поля:
- `value` — значение, хранимое в узле списка
- `next` — указатель на следующий узел (`Node<Type>*`)

---

#### Шаблонный класс `LinkedList<Type>`

> Реализация односвязного списка с возможностью вставки, удаления и итерирования элементов

```cpp
template<typename Type>
class LinkedList {
private:
    Node<Type>* head;
    Node<Type>* tail;
    size_t size;

public:
    ...
};
```

##### Поля:
- `head` — указатель на первый элемент списка
- `tail` — указатель на последний элемент
- `size` — текущее количество элементов

---

#### Методы:

- `LinkedList()`  
    > Конструктор по умолчанию

- `LinkedList(items: Type*, size: size_t)`  
    > Конструктор из массива  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **items** — массив значений  
    >   * **size** — количество элементов

- `LinkedList(linkedList: const LinkedList<Type>&)`  
    > Конструктор копирования

- `LinkedList(head: Type, args...)`  
    > Конструктор через список значений  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **head** — первый элемент  
    >   * **args** — остальные элементы

- `~LinkedList()`  
    > Деструктор. Освобождает все узлы списка

- `IsEmpty() const noexcept -> bool`  
    > Проверка, пуст ли список

- `Size() const noexcept -> size_t`  
    > Количество элементов

- `Get(index: int) const -> Type&`  
    > Получение значения по индексу

- `GetFirst() const -> Type&`  
    > Возвращает первый элемент

- `GetLast() const -> Type&`  
    > Возвращает последний элемент

- `Append(value: const Type&)`  
    > Добавляет элемент в конец

- `Prepend(value: const Type&)`  
    > Добавляет элемент в начало

- `Insert(index: int, value: const Type&)`  
    > Вставка по индексу

- `Remove(index: int)`  
    > Удаление по индексу

- `Begin() -> ListIterator`  
    > Итератор на начало списка

- `End() -> ListIterator`  
    > Итератор на `nullptr` (конец)

---

#### Операторы:

- `operator==(list: const LinkedList<Type>&) -> bool`  
    > Поэлементное сравнение списков

- `operator[](index: int) const -> Type&`  
    > Индексация (как массив)

- `operator<<(os: ostream&, list: const LinkedList&)`  
    > Вывод всех элементов в формате `[a, b, c]`

---

#### Вложенный класс `ListIterator`

```cpp
class ListIterator {
private:
    Node<Type>* current;
public:
    ...
};
```

##### Поля:
- `current` — указатель на текущий узел в итерации

##### Методы:

- `ListIterator()`  
    > Конструктор по умолчанию

- `ListIterator(node: Node<Type>*)`  
    > Конструктор из узла

- `operator++()`  
    > Переход к следующему элементу

- `operator*() -> Type&`  
    > Доступ к текущему значению

- `operator==(...)`, `operator!=...`  
    > Сравнение итераторов
  
---

### ListSequence.hpp

#### Шаблонный класс `ListSequence<Type>`

> Реализация абстрактной последовательности `Sequence<Type>` на основе односвязного списка `LinkedList<Type>`

```cpp
template<typename Type>
class ListSequence : public Sequence<Type> {
private:
    LinkedList<Type>* items;
public:
    ...
};
```

---

##### Поля:

- `items` — указатель на внутреннюю структуру хранения (`LinkedList<Type>*`), реализующую саму последовательность

---

#### Методы:

- `ListSequence()`  
    > Конструктор по умолчанию. Создаёт пустую последовательность

- `ListSequence(items: Type*, size: size_t)`  
    > Создаёт последовательность из массива  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **items** — указатель на массив  
    >   * **size** — количество элементов

- `ListSequence(listSequence: const ListSequence<Type>&)`  
    > Конструктор копирования

- `ListSequence(head: Type, args...)`  
    > Конструктор с произвольным числом аргументов  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **head, args...** — значения для инициализации последовательности

- `~ListSequence()`  
    > Деструктор. Освобождает память, занятую списком

- `Create() const -> Sequence<Type>*`  
    > Возвращает новую пустую последовательность типа `ListSequence`

- `Get(index: int) const -> Type&`  
    > Получает элемент по индексу  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `Size() const noexcept -> int`  
    > Возвращает количество элементов в последовательности

- `Append(item: const Type&) noexcept`  
    > Добавляет элемент в конец

- `Prepend(item: const Type&) noexcept`  
    > Добавляет элемент в начало

- `Insert(item: const Type&, index: int)`  
    > Вставляет элемент на заданную позицию  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — значение  
    >   * **index** — позиция

- `Remove(index: int)`  
    > Удаляет элемент по индексу

- `Begin() -> Iterator`  
    > Возвращает итератор на первый элемент

- `End() -> Iterator`  
    > Возвращает итератор, указывающий на `nullptr`
  
---

### Queue.hpp

#### Шаблонный класс `Queue<Type>`

> Очередь, реализованная поверх абстрактной последовательности `Sequence<Type>`. Поддерживает функциональные операции (`Map`, `Where`, `Reduce`).

```cpp
template<typename Type>
class Queue {
private:
    Sequence<Type>* items;
public:
    ...
};
```

---

##### Поля:

- `items` — последовательность, содержащая элементы очереди. По умолчанию инициализируется как `ListSequence<Type>`

---

#### Конструкторы и деструктор:

- `Queue()`  
    > Конструктор по умолчанию. Создаёт пустую очередь на основе `ListSequence`

- `Queue(items: Type*, size: size_t)`  
    > Создаёт очередь из массива  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **items** — массив элементов  
    >   * **size** — количество элементов

- `Queue(queue: const Queue<Type>&)`  
    > Конструктор копирования

- `Queue(sequence: const Sequence<Type>*)`  
    > Создание очереди из любой реализации последовательности  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **sequence** — указатель на последовательность

- `Queue(head: Type, args...)`  
    > Шаблонный конструктор через список значений  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **head, args...** — элементы, добавляемые в очередь

- `~Queue()`  
    > Деструктор. Освобождает память, занятую последовательностью

---

#### Методы:

- `Peek(index: size_t) const -> const Type&`  
    > Получает элемент по индексу, не извлекая из очереди  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент

- `Size() const noexcept -> size_t`  
    > Возвращает размер очереди

- `Append(val: const Type&) noexcept`  
    > Добавляет элемент в конец очереди  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **val** — добавляемое значение

- `Remove() -> Type`  
    > Удаляет и возвращает первый элемент  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Удалённый элемент

- `IsEmpty() const noexcept -> bool`  
    > Проверяет, пуста ли очередь

- `Map(func: Mapper<Type>) -> Queue<Type>`  
    > Возвращает новую очередь, в которой к каждому элементу применена функция  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **func** — функция отображения  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новая очередь

- `Where(filter: Condition<Type>) -> Queue<Type>`  
    > Фильтрует элементы по условию  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **filter** — логическая функция  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новая очередь

- `Reduce(reduce: Reducer<Type>, base: Type) const -> Type`  
    > Свёртка элементов с помощью аккумулятора  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **reduce** — аккумуляторная функция  
    >   * **base** — начальное значение  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Результат свёртки

---

#### Операторы:

- `operator<<(ostream& os, const Queue<Type>& queue)`  
    > Печатает очередь, используя перегруженный вывод внутренней последовательности


---

### Pair.hpp

#### Шаблонный класс `Pair<Type1, Type2>`

> Универсальная структура для хранения пары значений разных типов

```cpp
template<typename Type1, typename Type2>
class Pair {
private:
    Type1 first;
    Type2 last;
public:
    ...
};
```

---

##### Поля:

- `first` — первое значение пары (тип `Type1`)
- `last` — второе значение пары (тип `Type2`)

---

#### Конструкторы и деструктор:

- `Pair()`  
    > Конструктор по умолчанию  
    >
    > Инициализирует `first` и `last` значениями по умолчанию для соответствующих типов

- `Pair(val1: const Type1&, val2: const Type2&)`  
    > Инициализирует пару значениями `val1` и `val2`  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **val1** — значение для `first`  
    >   * **val2** — значение для `last`

- `Pair(other: const Pair<Type1, Type2>&)`  
    > Конструктор копирования

- `~Pair()`  
    > Деструктор (по умолчанию)

---

#### Методы:

- `GetFirst() const noexcept -> Type1`  
    > Возвращает значение поля `first`

- `GetLast() const noexcept -> Type2`  
    > Возвращает значение поля `last`

- `operator=(other: const Pair<Type1, Type2>&) -> Pair<Type1, Type2>&`  
    > Присваивает значения из другой пары  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **other** — другая пара  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на текущую пару

---

#### Операторы:

- `operator<<(os: ostream&, pair: const Pair<Type1, Type2>&)`  
    > Печатает пару в виде `(first, last)`


---

### QueueWithPriority.hpp

#### Шаблонный класс `PriorityQueue<Type1, Type2>`

> Очередь с приоритетом, реализованная на основе `Sequence` и хранящая пары (`Pair<Type1, Type2>`), где `Type2` используется как приоритет

```cpp
template<typename Type1, typename Type2>
class PriorityQueue {
private:
    Sequence<Pair<Type1, Type2>>* items;
public:
    ...
};
```

---

##### Поля:

- `items` — последовательность пар `(значение, приоритет)`, реализованная через `ListSequence`

---

#### Конструкторы и деструктор:

- `PriorityQueue()`  
    > Конструктор по умолчанию. Создаёт пустую очередь

- `PriorityQueue(items: Pair<Type1, Type2>*, size: size_t)`  
    > Конструктор из массива пар  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **items** — массив пар  
    >   * **size** — количество элементов

- `PriorityQueue(queue: const PriorityQueue<Type1, Type2>&)`  
    > Конструктор копирования  
    >
    > Копирует элементы с учётом приоритетов (через `InsertWithPriority`)

- `~PriorityQueue()`  
    > Деструктор. Освобождает память, занятую последовательностью

---

#### Методы:

- `Peek(ind: int) const -> const Pair<Type1, Type2>&`  
    > Возвращает элемент по индексу (не удаляя)

- `Size() const noexcept -> int`  
    > Количество элементов в очереди

- `Insert(item: const Pair<Type1, Type2>&, index: int)`  
    > Вставляет пару по конкретному индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — вставляемая пара  
    >   * **index** — позиция вставки

- `InsertWithPriority(value: Pair<Type1, Type2>) noexcept`  
    > Вставляет элемент с приоритетом:  
    > чем меньше значение `Type2`, тем выше приоритет  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **value** — пара `(данные, приоритет)`

- `concatWithPriority(queue: const PriorityQueue<Type1, Type2>&) -> PriorityQueue<Type1, Type2>`  
    > Объединяет текущую очередь с другой, сохраняя приоритеты  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **queue** — другая очередь  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новая очередь, содержащая элементы обеих

---

#### Операторы:

- `operator<<(ostream& os, const PriorityQueue<Type1, Type2>& queue)`  
    > Печатает очередь, используя формат вывода последовательности


---

### MenuQueue.hpp

#### Назначение

Модуль `MenuQueue.hpp` реализует консольное меню для демонстрации работы с:

- обычной очередью (`Queue<int>`)
- функциональными операциями (`Map`, `Where`, `Reduce`)
- очередями с приоритетами (`PriorityQueue<int, int>`)
- операцией объединения приоритетных очередей (`concatWithPriority`)

---

#### Макросы

- `PRINT`  
    > Вывод текущего состояния очереди:  
    > `Queue: [...]`

---

#### Функции

- `void talker()`  
    > Выводит список доступных пользователю операций:
    >
    > ```
    > 1. Print the queue  
    > 2. Append an element  
    > 3. Get an element by index  
    > 4. Get the length  
    > 5. Map  
    > 6. Where  
    > 7. Reduce  
    > 8. Concatenation with priority  
    > 0. Finish program
    > ```

---

- `void menu()`  
    > Основной цикл пользовательского взаимодействия

---

# Лабораторная работа №4  
_Обобщённая работа с бинарными деревьями на шаблонах_

---

## Постановка задачи  

Реализовать шаблонное бинарное дерево с базовыми операциями и поддержкой функциональных методов `Map`, `Where`, `Reduce`.  
Обеспечить интерфейс взаимодействия с деревом через консольное меню.

---

## Описание решения  

### Используемые типы данных  
- `Leaf<Type>` — структура узла дерева с ключом и двумя потомками  
- `BinaryTree<Type>` — основная структура бинарного дерева  
- `Mapper<Type>` — функция отображения одного значения (`Map`)  
- `Condition<Type>` — предикат-функция фильтрации (`Where`)  
- `Reducer<Type>` — функция свёртки (`Reduce`)  

---

## Функции

### Tree.hpp

#### Структура `Leaf<Type>`

> Узел бинарного дерева

```cpp
template<typename Type>
class Leaf {
private:
    Type value;
    Leaf* left;
    Leaf* right;
public:
    ...
};
```

##### Поля:
- `value` — значение, хранимое в узле
- `left` — левый потомок
- `right` — правый потомок

---

##### Методы:

- `Leaf()`  
    > Конструктор по умолчанию.  
    > Инициализирует пустой узел (`value = NULL`, потомки `nullptr`)

- `explicit Leaf(val: Type)`  
    > Конструктор с заданным значением  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **val** — значение, сохраняемое в узле

- `Get() -> Type&`  
    > Возвращает ссылку на значение, хранимое в узле

- `Left() -> Leaf*&`  
    > Возвращает ссылку на указатель левого поддерева  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на `left`

- `Right() -> Leaf*&`  
    > Возвращает ссылку на указатель правого поддерева  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на `right`

---

#### Шаблонный класс `BinaryTree<Type>`

> Класс бинарного дерева поиска с поддержкой операций `Map`, `Where`, `Reduce`

```cpp
template<typename Type>
class BinaryTree {
private:
    Leaf<Type>* root;
    int size;
public:
    ...
};
```

---

##### Поля:

- `root` — корневой узел дерева
- `size` — текущее количество элементов

---

#### Методы:

- `BinaryTree()`  
    > Конструктор по умолчанию. Инициализирует пустое дерево

- `~BinaryTree()`  
    > Деструктор. Рекурсивно удаляет все узлы дерева

- `Root() -> Leaf<Type>*&`  
    > Возвращает ссылку на корневой узел

- `Size() -> int&`  
    > Возвращает ссылку на размер дерева

- `Insert(key: Type)`  
    > Вставляет элемент в дерево по правилу BST  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **key** — значение для вставки

- `Remove(key: Type)`  
    > Удаляет элемент из дерева (BST-логика)

- `Find(key: Type) -> bool`  
    > Проверяет наличие элемента в дереве

- `PrintPLR(leaf: Leaf<Type>*)`  
    > Обходит дерево в прямом порядке (лево → право → корень)  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **leaf** — начальный узел

- `PrintPRL(leaf: Leaf<Type>*)`  
    > Обходит дерево в обратном порядке (право → лево → корень)

- `Clear(leaf: Leaf<Type>*)`  
    > Удаляет поддерево, начиная с заданного узла

- `deleteTree(leaf: Leaf<Type>*)`  
    > Рекурсивно удаляет всё дерево  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **leaf** — текущий узел, с которого начать удаление

---

#### Функциональные методы:

- `Map(func: Mapper<Type>)`  
    > Применяет функцию ко всем элементам дерева

    > _ПАРАМЕТРЫ:_  
    >   * **func** — функция `Type func(Type&)`

- `Where(filter: Condition<Type>)`  
    > Удаляет все элементы, не удовлетворяющие условию

    > _ПАРАМЕТРЫ:_  
    >   * **filter** — логическая функция `bool func(Type&)`

- `Reduce(reduce: Reducer<Type>)`  
    > Сворачивает всё дерево в один элемент  
    > Заменяет дерево одним новым узлом — результатом

    > _ПАРАМЕТРЫ:_  
    >   * **reduce** — функция `Type func(const Type&, const Type&)`

---

#### Вспомогательные приватные методы:

- `ChangerMap(...)` — рекурсивно применяет `Map`
- `ChangerWhere(...)` — собирает в `set` все неподходящие элементы
- `ChangerReduce(...)` — рекурсивно применяет аккумуляцию `Reduce`

---

### Test.hpp

#### Назначение

Файл `Test.hpp` содержит модульные тесты для проверки корректности работы бинарного дерева `BinaryTree<Type>`.

---

#### Функции:

- `testTree()`  
    > Запускает последовательные проверки основных операций над деревом:  
    > создание, вставка, фильтрация (`Where`), отображение (`Map`), свёртка (`Reduce`).

---

#### Итог:

Если все `assert`-проверки проходят успешно, выводятся подтверждения:
```
Create tests were passed!
Insert tests were passed!
Where tests were passed!
Map tests were passed!
Reduce tests were passed!
Tree tests were passed!
```

---

### menu.hpp

#### Назначение

Файл `menu.hpp` реализует консольное меню для взаимодействия с бинарным деревом поиска `BinaryTree<int>`. Пользователь может выполнять над деревом базовые и функциональные операции.

---

#### Макросы

- `EMPTY`  
    > Проверяет, пусто ли дерево (`tree->Root() == nullptr`)  
    > Если да — выводит `Empty` и завершает текущую операцию

- `PRINT_PLR`  
    > Обходит дерево в порядке: Лево → Право → Корень (`PrintPLR`)  
    > Только если дерево не пустое

- `PRINT_PRL`  
    > Обходит дерево в порядке: Право → Лево → Корень (`PrintPRL`)  
    > Только если дерево не пустое

---

#### Функции

- `void talker()`  
    > Выводит на экран список доступных команд:
    ```
    1. New tree from array  
    2. Insert the note  
    3. Find the key  
    4. Print the tree (PLR)  
    5. Print the tree (PRL)  
    6. Remove the note  
    7. Map()  
    8. Where()  
    9. Reduce()  
    10. Get the Size of tree  
    0. Finish program
    ```

---

- `void menu()`  
    > Основной цикл взаимодействия с пользователем через стандартный ввод/вывод  
    > Создаётся объект `BinaryTree<int>`, и обрабатываются пользовательские команды
  