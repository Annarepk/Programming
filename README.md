# Лабораторная работа №1  
_Матричные операции с элементами кольца_

---

## Постановка задачи  

Реализовать операции над матрицами с элементами, принадлежащими кольцу.  
Создать интерфейс для работы с различными типами данных (например, `int`, `float`).  
Обеспечить корректную работу функций: сложения, умножения и транспонирования матриц.

---

## Описание решения  
### Используемые типы данных  
- `RingInfo` — структура, содержащая указатели на функции, реализующие операции над элементами кольца:
  - `Create`, `Add`, `Mult`, `Input`, `Print`, `Delete`
- `void*` — универсальный указатель для работы с абстрактными элементами
- `Matrix` — структура, содержащая размеры, массив элементов и ссылку на `RingInfo`

---

## Функции

### Float.c / Int.c

- `Create() -> void*`  
    > Создаёт новый элемент заданного типа (`int` или `float`)
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Указатель на созданный элемент  

- `Add(a: void*, b: void*) -> void*`  
    > Складывает два элемента
    >
    > _ПАРАМЕТРЫ:_  
    >   * **a** - первый элемент  
    >   * **b** - второй элемент  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Указатель на результат сложения  

- `Mult(a: void*, b: void*) -> void*`  
    > Перемножает два элемента
    >
    > _ПАРАМЕТРЫ:_  
    >   * **a** - первый элемент  
    >   * **b** - второй элемент  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Указатель на результат умножения  

- `Input() -> void*`  
    > Считывает значение элемента из ввода  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Указатель на считанный элемент  

- `Print(a: void*)`  
    > Выводит элемент на экран  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **a** - элемент для вывода  

- `Delete(a: void*)`  
    > Освобождает память, выделенную под элемент  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **a** - элемент для удаления  

---

### Matrix.c

- `CreateMatrix(rows: int, cols: int, ring: RingInfo*) -> Matrix*`  
    > Создаёт матрицу заданного размера и с заданными операциями кольца  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **rows** - количество строк  
    >   * **cols** - количество столбцов  
    >   * **ring** - указатель на структуру `RingInfo`  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Указатель на созданную матрицу  

- `InputMatrix(matrix: Matrix*)`  
    > Считывает значения всех элементов матрицы  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **matrix** - матрица для ввода значений  

- `PrintMatrix(matrix: Matrix*)`  
    > Выводит матрицу на экран  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **matrix** - матрица для вывода  

- `AddMatrix(a: Matrix*, b: Matrix*) -> Matrix*`  
    > Складывает две матрицы одинакового размера  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **a** - первая матрица  
    >   * **b** - вторая матрица  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Результирующая матрица  

- `MultMatrix(a: Matrix*, b: Matrix*) -> Matrix*`  
    > Умножает две совместимые по размерам матрицы  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **a** - первая матрица  
    >   * **b** - вторая матрица  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Результирующая матрица  

- `TransposeMatrix(matrix: Matrix*) -> Matrix*`  
    > Создаёт транспонированную копию матрицы  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **matrix** - исходная матрица  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Транспонированная матрица  

- `DeleteMatrix(matrix: Matrix*)`  
    > Освобождает память, занятую матрицей  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **matrix** - матрица для удаления  

---

### Menu.h

- `Menu()`  
    > Запускает текстовый интерфейс программы и обрабатывает действия пользователя  

---

# Лабораторная работа №2  
_Обобщённая работа с последовательностями на шаблонах_

---

## Постановка задачи  

Реализовать иерархию классов для работы с последовательностями с использованием шаблонов.  
Поддержать основные операции (вставка, удаление, доступ по индексу, фильтрация, отображение, свёртка).  
Обеспечить интерфейс пользователя для работы с различными типами данных (например, `int`, `float`).

---

## Описание решения  
### Используемые типы данных  
- `Sequence<Type>` — абстрактный класс для последовательностей  
- `ArraySequence<Type>` — реализация последовательности на динамическом массиве  
- `ListSequence<Type>` — реализация последовательности на двусвязном списке  
- `Mapper<Type>` — функция, применяемая к каждому элементу (аналог map)  
- `Condition<Type>` — функция-фильтр (аналог filter)  
- `Reducer<Type>` — функция для свёртки значений (аналог reduce)  

---

## Функции

### Sequence.hpp

- `Create() const -> Sequence<Type>*`  
    > Создаёт новую пустую последовательность того же типа  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Указатель на новую пустую последовательность  

- `Get(index: int) const -> Type&`  
    > Возвращает элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — индекс элемента  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент  

- `Size() const noexcept -> int`  
    > Возвращает количество элементов  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Количество элементов  

- `Append(item: const Type&) noexcept`  
    > Добавляет элемент в конец  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — элемент, который нужно добавить  

- `Prepend(item: const Type&) noexcept`  
    > Добавляет элемент в начало  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — элемент, который нужно добавить  

- `Insert(item: const Type&, index: int)`  
    > Вставляет элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — элемент для вставки  
    >   * **index** — позиция вставки  

- `Remove(index: int)`  
    > Удаляет элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — индекс удаляемого элемента  

- `IsEmpty() const -> bool`  
    > Проверяет, пуста ли последовательность  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * `true`, если пуста; `false` — иначе  

- `GetFirst() const -> Type&`  
    > Возвращает первый элемент  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на первый элемент  

- `GetLast() const -> Type&`  
    > Возвращает последний элемент  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на последний элемент  

- `Map(func: Mapper<Type>) const -> Sequence<Type>*`  
    > Применяет функцию ко всем элементам  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **func** — функция для преобразования  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новая последовательность  

- `Where(filter: Condition<Type>) const -> Sequence<Type>*`  
    > Фильтрует элементы  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **filter** — условие фильтрации  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новая отфильтрованная последовательность  

- `Reduce(func: Reducer<Type>, start: const Type&) const -> Type`  
    > Выполняет свёртку  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **func** — функция свёртки  
    >   * **start** — начальное значение  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Результат свёртки  

---

### ArraySequence.hpp / ListSequence.hpp

- `Append(item: const Type&)`  
    > Добавляет элемент в конец  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — элемент для добавления  

- `Prepend(item: const Type&)`  
    > Добавляет элемент в начало  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — элемент для добавления  

- `Insert(item: const Type&, index: int)`  
    > Вставляет элемент на позицию  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — вставляемый элемент  
    >   * **index** — индекс вставки  

- `Remove(index: int)`  
    > Удаляет элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — индекс удаляемого элемента  

- `Create() const -> Sequence<Type>*`  
    > Создаёт пустую последовательность  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Указатель на новую пустую последовательность  

---

### DynamicArray.hpp

- `Get(index: int) const -> Type&`  
    > Возвращает элемент  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — индекс элемента  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент  

- `Set(index: int, element: Type)`  
    > Устанавливает значение по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — позиция  
    >   * **element** — новое значение  

- `Resize(newSize: size_t)`  
    > Меняет размер массива  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **newSize** — новый размер  

- `GetSize() const -> int`  
    > Возвращает размер массива  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Размер массива  

---

### List.hpp

- `Append(item: Type)`  
    > Добавляет в конец  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — элемент  

- `Prepend(item: Type)`  
    > Добавляет в начало  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — элемент  

- `Insert(item: Type, index: int)`  
    > Вставляет элемент  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — вставляемый элемент  
    >   * **index** — индекс  

- `Remove(index: int)`  
    > Удаляет элемент  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — индекс  

- `Get(index: int) -> Type&`  
    > Возвращает элемент  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — позиция  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Ссылка на элемент  

- `GetSize() const -> int`  
    > Возвращает размер списка  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Количество элементов  

---

### Menu.hpp

- `Menu()`  
    > Запускает консольный пользовательский интерфейс

---

# Лабораторная работа №3  
_Очереди и приоритетные очереди на обобщённых структурах_

---

## Постановка задачи  

Реализовать обобщённую очередь (`Queue<Type>`) с поддержкой операций добавления, удаления и отображения.  
Дополнительно реализовать приоритетную очередь (`PriorityQueue<Key, Priority>`), основанную на очереди пар ключ-приоритет.  
Поддержать работу с различными типами данных (`int`, `float`, `Complex`, и т. д.) через шаблоны.  
Обеспечить возможность применения функций `Map`, `Where`, `Reduce` к элементам очереди.  
Создать интерфейс взаимодействия с пользователем.

---

## Описание решения  
### Используемые типы данных  
- `Queue<Type>` — шаблонная очередь, реализованная через `Sequence<Type>`  
- `PriorityQueue<Key, Priority>` — шаблонная приоритетная очередь на базе `Queue<Pair<Key, Priority>>`  
- `Pair<Type1, Type2>` — пара значений с шаблонными типами  
- `Complex` — структура для комплексных чисел  
- `Mapper<T>`, `Condition<T>`, `Reducer<T>` — функции отображения, фильтрации и свёртки  

---

## Функции

### Queue.hpp

- `Queue()`  
    > Конструктор по умолчанию  

- `Queue(items: Type*, size: size_t)`  
    > Создаёт очередь из массива элементов  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **items** — указатель на массив элементов  
    >   * **size** — количество элементов в массиве  

- `Queue(sequence: const Sequence<Type>*)`  
    > Конструктор по указателю на последовательность  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **sequence** — указатель на объект `Sequence<Type>`  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Копия последовательности в виде очереди  

- `Peek(index: size_t) -> const Type&`  
    > Возвращает элемент по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **index** — индекс элемента  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Константная ссылка на элемент  

- `Append(val: const Type&)`  
    > Добавляет элемент в конец очереди  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **val** — добавляемый элемент  

- `Remove() -> Type`  
    > Удаляет и возвращает первый элемент очереди  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Удалённый элемент  

- `IsEmpty() -> bool`  
    > Проверяет, пуста ли очередь  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * `true`, если очередь пуста, иначе `false`  

- `Map(func: Mapper<Type>) -> Queue<Type>`  
    > Возвращает очередь, полученную применением функции к каждому элементу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **func** — функция отображения (map)  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новая очередь с преобразованными элементами  

- `Where(filter: Condition<Type>) -> Queue<Type>`  
    > Фильтрует элементы очереди  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **filter** — логическая функция-фильтр  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новая очередь с элементами, удовлетворяющими фильтру  

- `Reduce(func: Reducer<Type>, start: Type) -> Type`  
    > Выполняет свёртку всех элементов очереди  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **func** — функция свёртки  
    >   * **start** — начальное значение  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Результат применения свёртки к очереди  

---

### PriorityQueue.hpp

- `InsertWithPriority(pair: Pair<Key, Priority>)`  
    > Добавляет пару ключ-приоритет в очередь  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **pair** — добавляемая пара  

- `concatWithPriority(other: const PriorityQueue&) -> PriorityQueue<Key, Priority>`  
    > Объединяет две приоритетные очереди  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **other** — вторая очередь  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Новая объединённая очередь  

- `Insert(item: const Pair<Key, Priority>&, index: int)`  
    > Вставляет элемент в очередь по индексу  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **item** — элемент для вставки  
    >   * **index** — позиция вставки  

---

### Pair.hpp

- `Pair(first: Type1, second: Type2)`  
    > Конструктор пары значений  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **first** — значение первого типа  
    >   * **second** — значение второго типа  

---

### Complex.hpp

- `Complex(re: double, im: double)`  
    > Конструктор комплексного числа  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **re** — действительная часть  
    >   * **im** — мнимая часть  

- `operator+(other: const Complex&) -> Complex`  
    > Сложение комплексных чисел  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **other** — второе слагаемое  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Сумма двух комплексных чисел  

- `operator*(other: const Complex&) -> Complex`  
    > Умножение комплексных чисел  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **other** — второй множитель  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * Произведение двух комплексных чисел  

---

### MenuQueue.hpp

- `menu()`  
    > Запускает пользовательский интерфейс с возможностью работы с очередями  

---

# Лабораторная работа №4  
_Обобщённая работа с бинарными деревьями на шаблонах_

---

## Постановка задачи  

Реализовать шаблонное бинарное дерево с базовыми операциями и поддержкой функциональных методов `Map`, `Where`, `Reduce`.  
Обеспечить интерфейс взаимодействия с деревом через консольное меню.

---

## Описание решения  

### Используемые типы данных  
- `Leaf<Type>` — структура узла дерева с ключом и двумя потомками  
- `BinaryTree<Type>` — основная структура бинарного дерева  
- `Mapper<Type>` — функция отображения одного значения (`Map`)  
- `Condition<Type>` — предикат-функция фильтрации (`Where`)  
- `Reducer<Type>` — функция свёртки (`Reduce`)  

---

## Функции

### Tree.hpp

- `Insert(key: Type)`  
    > Вставляет узел с заданным значением  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **key** — значение для вставки  

- `Remove(key: Type)`  
    > Удаляет узел с заданным значением  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **key** — значение, которое нужно удалить  

- `Find(key: Type) -> bool`  
    > Проверяет наличие элемента  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **key** — значение для поиска  
    >
    > _ВОЗВРАЩАЕТ:_  
    >   * true, если элемент найден, иначе false  

- `Map(func: Mapper<Type>)`  
    > Применяет функцию к каждому элементу, перестраивая дерево  

- `Where(filter: Condition<Type>)`  
    > Удаляет все элементы, не удовлетворяющие условию  

- `Reduce(func: Reducer<Type>)`  
    > Производит свёртку всех элементов дерева в один результат  

- `PrintPLR(leaf: Leaf<Type>*)`  
    > Обход дерева в порядке `лево → право → корень`  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **leaf** — корневой узел (обычно `this->Root()`)  

- `PrintPRL(leaf: Leaf<Type>*)`  
    > Обход дерева в порядке `право → лево → корень`  
    >
    > _ПАРАМЕТРЫ:_  
    >   * **leaf** — корневой узел  

---

### menu.hpp

- `menu()`  
    > Консольное меню для взаимодействия с бинарным деревом:  
    > вставка, поиск, вывод, Map, Where, Reduce  

---

### Test.hpp

- `testTree()`  
    > Автоматические тесты на корректность операций `Insert`, `Find`, `Map`, `Where`, `Reduce`

